<!DOCTYPE html>
<html>
<head>
    <title>HTML5 Puzzle</title>
    <script>
	const PUZZLE_DIFFICULTY = 4; //holds the number of pieces in the puzzle (4 x 4)
	const PUZZLE_HOVER_TINT = '#009900'; 
	 
	var _canvas; //reference to the canvas
	var _stage; //reference to canvas' drawing context
	 
	var _img; //reference to the loaded image
	var _pieces;
	
	/*These variables store the dimensions of both
	the entire puzzle and each individual puzzle piece
	*/
	var _puzzleWidth;
	var _puzzleHeight;
	var _pieceWidth;
	var _pieceHeight;
	var _currentPiece; //reference to the piece currently being dragged
	var _currentDropPiece; //reference to the piece currently in position to be dropped on. Highlighted green
	
	//reference that will hold mouse's current x and y position
    //updated when the puzzle is clicked to determine what piece it's hovering over.	
	var _mouse;
	
	function init()
	{
		_img = new Image(); //the image object is instantiated and set to _img
		_img.addEventListener('load', onImage,false); //listen for the load event which will fire onImage() function when the image is no longer loading
		_img.src = "speedforce.jpg"; //set the source of the image, thus triggering the load.
	}
	
	function onImage()
	{
		//Calculate the size of each puzzle piece by dividing image dimensions by PUZZLE_DIFFICULTY
		_pieceWidth = Math.floor(_img.width / PUZZLE_DIFFICULTY);
		_pieceHeight = Math.floor(_img.height / PUZZLE_DIFFICULTY);
		
		//Use size of puzzle pieces to determine size of the puzzle
		_puzzleWidth = _pieceWidth * PUZZLE_DIFFICULTY;
		_puzzleHeight = _pieceHeight * PUZZLE_DIFFICULTY;
		
		//set canvas and puzzle once sizes have been determined
		setCanvas();
		initPuzzle();
	}
	
	function setCanvas()
	{	//reference the canvas id and store reference in _canvas
		//reference the _stage's context
		_canvas = document.getElementById('canvas');
		_stage = _canvas.getContext('2d');
		
		//make canvas the same size as the puzzle, and establish a border around it
		_canvas.width = _puzzleWidth;
		_canvas.height = _puzzleHeight;
		_canvas.style.border = "1px solid black";
	}
	
	function initPuzzle()
	{
		_pieces = [];
		_mouse = {x:0,y:0};
		_currentPiece = null;
		_currentDropPiece = null;
		_stage.drawImage(_img, 0, 0, _puzzleWidth, _puzzleHeight, 0, 0, _puzzleWidth, _puzzleHeight);
		createTitle("Click to Start Puzzle");
		buildPieces();
	}
	
	function createTitle(msg)
	{
		_stage.fillStyle = "#000000";
		_stage.globalAlpha = .4;
		_stage.fillRect(100, _puzzleHeight - 40, _puzzleWidth - 200, 40);
		_stage.fillStyle = "#FFFFFF";
		_stage.globalAlpha = 1;
		_stage.textAlign = "center";
		_stage.textBaseline = "middle";
		_stage.font = "20px Arial";
		_stage.fillText(msg, _puzzleWidth / 2, _puzzleHeight - 20);
	}
	
	function buildPieces()
	{
		var i;
		var piece;
		var xPos = 0;
		var yPos = 0;
		for (i = 0; i < PUZZLE_DIFFICULTY * PUZZLE_DIFFICULTY; i++)
		{
			piece = {};
			piece.sx = xPos;
			piece.sy = yPos;
			_pieces.push(piece);
			xPos += _pieceWidth;
			if (xPos >= _puzzleWidth)
			{
				xPos = 0;
				yPos += _pieceHeight;
			}
		}
		
		document.onmousedown = shufflePuzzle;
	}
	
	function shufflePuzzle()
	{
		_pieces = shuffleArray(_pieces);
		_stage.clearRect(0, 0, _puzzleWidth, _puzzleHeight);
		var i;
		var piece;
		var xPos = 0;
		var yPos = 0;
		
		for(i = 0; i < _pieces.length; i++)
		{
			piece = _pieces[i];
			piece.xPos = xPos;
			piece.yPos = yPos;
			_stage.drawImage(_img, piece.sx, piece.sy, _pieceWidth, _pieceHeight, xPos, yPos, _pieceWidth, _pieceHeight);
			_stage.strokeRect(xPos, yPos, _pieceWidth, _pieceHeight);
			xPos += _pieceWidth;
			if(xPos >= _puzzleWidth)
			{
				xPos = 0;
				yPos += _pieceHeight;
			}
			
		}
		document.onmousedown = onPuzzleClick;
	}
	
	function shuffleArray(o)
	{//explain this
		for(var j, x, i = o.length; i; j = parseInt(Math.random() * i), x = o[--i], o[i] = o[j], o[j] = x);
		return o;
	}
	
	function onPuzzleClick()
	{
	 /*
		We know that the puzzle was clicked; now we need to determine what piece was clicked on. 
		This simple conditional will get us our mouse position on all modern desktop browsers 
		that support canvas, using either e.layerX and e.layerY or e.offsetX and e.offsetY. 
		Use these values to update our _mouse object by assigning it an x and a y property to 
		hold the current mouse position - in this case, the position where it was clicked.

		In line 112 we then immediately set _currentPiece to the returned value from our 
		checkPieceClicked() function. We separate this code because we want to use it later 
		when dragging the puzzle piece. I’ll explain this function in the next step.
		
		If the value returned was null, we simply do nothing, as this implies that the user 
		didn’t actually click on a puzzle piece. However, if we do retrieve a puzzle piece, 
		we want to attach it to the mouse and fade it out a bit to reveal the pieces underneath.
		So how do we do this?

		First we clear the canvas area where the piece sat before we clicked it. We use clearRect()
		once again, but in this case we pass in only the area obtained from the _currentPiece 
		object. Before we redraw it, we want to save() the context of the canvas before proceeding.
		This will assure that anything we draw after saving will not simply draw over anything in 
		its way. We do this because we’ll be slightly fading the dragged piece and want to see the
		pieces under it. If we didn’t call save(), we’d just draw over any graphics in the way - 
		faded or not.

		Now we draw the image so its center is positioned at the mouse pointer. The first 5 
		parameters of drawImage will always be the same throughout the application. When clicking, 
		the next two parameters will be updated to center itself to the pointer of the mouse. The 
		last two parameters, the width and height to draw, will also never change.

		Lastly we call the restore() method. This essentially means we are done using the new alpha 
		value and want to restore all properties back to where they were. To wrap up this function 
		we add two more listeners. One for when we move the mouse (dragging the puzzle piece), and 
		one for when we let go (drop the puzzle piece).
	 */
		if(e.layerX || e.layerX == 0)
		{
			_mouse.x = e.layerX - _canvas.offsetLeft;
			_mouse.y = e.layerY - _canvas.offsetTop;
		}
		else if(e.offsetX || e.offsetX == 0)
		{
			_mouse.x = e.offsetX - _canvas.offsetLeft;
			_mouse.y = e.offsetY - _canvas.offsetTop;
		}
		
		_currentPiece = checkPieceClicked();
		
		if(_currentPiece != null)
		{
			_stage.clearRect(_currentPiece.xPos,_currentPiece.yPos,_pieceWidth,_pieceHeight);
			_stage.save();
			_stage.globalAlpha = .9;
			_stage.drawImage(_img, _currentPiece.sx, _currentPiece.sy, _pieceWidth, _pieceHeight, _mouse.x - (_pieceWidth / 2), _mouse.y - (_pieceHeight / 2), _pieceWidth, _pieceHeight);
			_stage.restore();
			document.onmousemove = updatePuzzle;
			document.onmouseup = pieceDropped;
		}
	}
	
	
	function checkPieceClicked()
	{
		var i;
		var piece;
		for(i = 0;i < _pieces.length;i++)
		{
			piece = _pieces[i];
			if(_mouse.x < piece.xPos || _mouse.x > (piece.xPos + _pieceWidth) || _mouse.y < piece.yPos || _mouse.y > (piece.yPos + _pieceHeight))
			{
            //PIECE NOT HIT
			}
        
			else
			{
				return piece;
			}
		}
    
		return null;
	}
	
	
	
	function updatePuzzle(e)
	{
		_currentDropPiece = null;
		if(e.layerX || e.layerX == 0)
		{
			_mouse.x = e.layerX - _canvas.offsetLeft;
			_mouse.y = e.layerY - _canvas.offsetTop;
		}
		else if(e.offsetX || e.offsetX == 0)
		{
			_mouse.x = e.offsetX - _canvas.offsetLeft;
			_mouse.y = e.offsetY - _canvas.offsetTop;
		}
		
		_stage.clearRect(0,0,_puzzleWidth,_puzzleHeight);
		var i;
		var piece;
		
		for(i = 0;i < _pieces.length;i++)
		{
			piece = _pieces[i];
			if(piece == _currentPiece)
			{
				continue;
			}
			_stage.drawImage(_img, piece.sx, piece.sy, _pieceWidth, _pieceHeight, piece.xPos, piece.yPos, _pieceWidth, _pieceHeight);
			_stage.strokeRect(piece.xPos, piece.yPos, _pieceWidth,_pieceHeight);
			if(_currentDropPiece == null)
			{
				if(_mouse.x < piece.xPos || _mouse.x > (piece.xPos + _pieceWidth) || _mouse.y < piece.yPos || _mouse.y > (piece.yPos + _pieceHeight))
				{
					//NOT OVER
				}
				else
				{
					_currentDropPiece = piece;
					_stage.save();
					_stage.globalAlpha = .4;
					_stage.fillStyle = PUZZLE_HOVER_TINT;
					_stage.fillRect(_currentDropPiece.xPos,_currentDropPiece.yPos,_pieceWidth, _pieceHeight);
					_stage.restore();
				}
			}
		}
		_stage.save();
		_stage.globalAlpha = .6;
		_stage.drawImage(_img, _currentPiece.sx, _currentPiece.sy, _pieceWidth, _pieceHeight, _mouse.x - (_pieceWidth / 2), _mouse.y - (_pieceHeight / 2), _pieceWidth, _pieceHeight);
		_stage.restore();
		_stage.strokeRect( _mouse.x - (_pieceWidth / 2), _mouse.y - (_pieceHeight / 2), _pieceWidth,_pieceHeight);
	}
	
	
	function pieceDropped(e)
	{
		document.onmousemove = null;
		document.onmouseup = null;
		if(_currentDropPiece != null)
		{
			var tmp = {xPos:_currentPiece.xPos,yPos:_currentPiece.yPos};
			_currentPiece.xPos = _currentDropPiece.xPos;
			_currentPiece.yPos = _currentDropPiece.yPos;
			_currentDropPiece.xPos = tmp.xPos;
			_currentDropPiece.yPos = tmp.yPos;
		}
		resetPuzzleAndCheckWin();
	}
	
	
	function resetPuzzleAndCheckWin()
	{
		_stage.clearRect(0,0,_puzzleWidth,_puzzleHeight);
		var gameWin = true;
		var i;
		var piece;
		for(i = 0;i < _pieces.length;i++)
		{
			piece = _pieces[i];
			_stage.drawImage(_img, piece.sx, piece.sy, _pieceWidth, _pieceHeight, piece.xPos, piece.yPos, _pieceWidth, _pieceHeight);
			_stage.strokeRect(piece.xPos, piece.yPos, _pieceWidth,_pieceHeight);
			if(piece.xPos != piece.sx || piece.yPos != piece.sy)
			{
				gameWin = false;
			}
		}
		if(gameWin)
		{
			setTimeout(gameOver,500);
		}
	}
	
	
	function gameOver()
	{
		document.onmousedown = null;
		document.onmousemove = null;
		document.onmouseup = null;
		initPuzzle();
	}
    </script>
	
</head>
 
<body onload="init();">


    <canvas id="canvas"></canvas>
	
	
</body>
 
</html>